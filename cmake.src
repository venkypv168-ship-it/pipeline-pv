#include <stdint.h>
#include <stdio.h>
// Simulate an LED toggle function (stub)
void toggle_led(void) {
    static int state = 0;
    state = !state;
    printf("LED is now %s\n", state ? "ON" : "OFF");
}
// Simulate delay (not suitable for real-time)
void delay(unsigned int count) {
    for (volatile unsigned int i = 0; i < count * 100000; ++i);
}
int main(void) {
    printf("Starting minimal firmware...\n");
    while (1) {
        toggle_led();
        delay(10);  // delay to simulate periodic action
    }
    return 0;  // Never reached
}


CMakeLists.txt:
cmake_minimum_required(VERSION 3.10)
project(MyFirmware C)

set(CMAKE_C_STANDARD 11)

# Set toolchain if needed
if(NOT DEFINED CMAKE_TOOLCHAIN_FILE)
    # Uncomment below if using ARM
    # set(CMAKE_C_COMPILER arm-none-eabi-gcc)
    # set(CMAKE_OBJCOPY arm-none-eabi-objcopy)
    find_program(CMAKE_OBJCOPY NAMES arm-none-eabi-objcopy objcopy)
endif()

add_executable(myfirmware.elf
    src/main.c
)

# Add custom command to generate .bin from .elf
add_custom_command(TARGET myfirmware.elf POST_BUILD
    COMMAND ${CMAKE_OBJCOPY} -O binary myfirmware.elf myfirmware.bin
    COMMENT “Generating .bin from .elf”
)

Build.sh:
#!/bin/bash
set -e  # Exit on error

# Move to project root (if not already there)
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
cd "$SCRIPT_DIR"

# Create and enter build directory
mkdir -p build
cd build

# Run cmake on the parent folder
cmake ..

# Build the firmware
make

echo "✅ Build output:"
ls -lh *.elf *.bin

Jenkinsfile:
pipeline {
    agent { label 'linuxgit' }

    environment {
        GIT_REPO = 'https://github.com/venkypv168-ship-it/pipeline-pv.git'
        BRANCH = 'main'
    }
    
    stages {
        stage('Clean Workspace') {
            steps {
                echo 'CLeaning workspace'
                deleteDir()
            }
        }
        stage('Lint') {
            steps {
                echo "Cloning the repo from Gitlab ........."
                git branch: "${BRANCH}",
                    url: "${GIT_REPO}",
                    credentialsId: 'gitlab'
            }
        }
        stage('Build') {
            steps {
                sh 'dos2unix build.sh'
                sh 'chmod +x build.sh'
                sh 'bash build.sh'
          }
        }
    }
}
post {
        always {
        unstable {
            echo 'Build marked as UNSTABLE!'
            emailext (
                subject: "Build Unstable: ${env.JOB_NAME} [#${env.BUILD_NUMBER}]",
                body: """<p>Build became <b>UNSTABLE</b> in job <b>${env.JOB_NAME}</b> [#${env.BUILD_NUMBER}]</p>""",
                recipientProviders: [[$class: 'DevelopersRecipientProvider']]
            )
        }
        failure {
            echo 'Build failed!'
            emailext (
                subject: "Build Failed: ${env.JOB_NAME} [#${env.BUILD_NUMBER}]",
                body: """<p>Build failed in job <b>${env.JOB_NAME}</b> [#${env.BUILD_NUMBER}]</p>""",
                recipientProviders: [[$class: 'DevelopersRecipientProvider']]
            )
        }
    }
